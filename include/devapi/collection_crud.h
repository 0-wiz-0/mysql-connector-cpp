/*
 * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
 *
 * The MySQL Connector/C++ is licensed under the terms of the GPLv2
 * <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
 * MySQL Connectors. There are special exceptions to the terms and
 * conditions of the GPLv2 as it is applied to this software, see the
 * FLOSS License Exception
 * <http://www.mysql.com/about/legal/licensing/foss-exception.html>.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
 */

#ifndef MYSQLX_COLLECTION_CRUD_H
#define MYSQLX_COLLECTION_CRUD_H

/**
  @file
  Declarations for CRUD operations on document collections.

  Classes declared here represent CRUD operations on a given document
  collection. An Object of a class such as CollectionAdd represents
  a "yet-to-be-executed" operation and stores all the parameters for the
  operation. The operation is sent to server for execution only when
  `execute()` method is called.

  The following classes for collection CRUD operations are defined:
  - CollectionAdd
  - CollectionRemove
  - CollectionFind
  - CollectionModify

  CRUD operation objects can be created directly, or assigned from
  result of DevAPI methods that create such operations:
  ~~~~~~
     CollectionAdd  add_op(coll);
     CollectionFind find_op = coll.find(...).sort(...);
  ~~~~~~

  CRUD operation objects have methods which can modify the operation
  before it gets executed. For example `CollectionAdd::add()`
  appends a document to the list of documents that should be added
  by given CollectionAdd operation. These methods can be chained
  as allowed by the fluent API grammar.

  The order of fluent API calls is expressed by base classes, such as
  Collection_find_base, which are composed from CRUD templates defined
  in crud.h. The order of templates determines the allowed order of fluent
  API calls.
*/


#include "common.h"
#include "result.h"
#include "executable.h"
#include "crud.h"
#include "detail/collection_crud.h"


namespace cdk {

class Session;

}  // cdk


namespace mysqlx {

class Session;
class Collection;

// ----------------------------------------------------------------------

/*
  Adding documents to a collection
  ================================
*/

class CollectionAdd;

namespace internal {

/*
  Note: using empty class instead of alias/typedef to help Doxygen correctly
  expand templates.
*/

struct Collection_add_base
  : public Executable<Result, CollectionAdd>
{};

}


/**
  Operation which adds documents to a collection.

  Documents to be added by this operation are specified with various variants
  of `add()` method.

  Each document must have a unique identifier which is stored in `_id`
  field of the document. Document identifiers are character strings no longer
  than 32 characters. If added document does not have `_id` field, a unique
  identifier will be generated for it. Document identifier generated by given
  collection add operation can be examined using `Result::getDocumentIds()`
  method. Generated document identifiers are string of 32 hexadecimal digits,
  like this one `0512020981044082E6119DFA0E4C0584`.

  @note Generated document identifiers are based on UUIDs but they are not
  valid UUIDs (fields are reversed).

  @ingroup devapi_op

  @internal
  The various `add()` methods are implemented in terms of `do_add()` method
  defined by Collection_add_detail class. This method passes documents to
  the internal implementation object.
*/

DLL_WARNINGS_PUSH

class PUBLIC_API CollectionAdd
  : public internal::Collection_add_base
  , internal::Collection_add_detail
{

DLL_WARNINGS_POP

public:

  /**
    Create empty add operation for a given collection.
  */

  CollectionAdd(Collection &coll);

  CollectionAdd(const internal::Collection_add_base &other)
  {
    internal::Collection_add_base::operator=(other);
  }

  CollectionAdd(internal::Collection_add_base &&other)
  {
    internal::Collection_add_base::operator=(std::move(other));
  }


  /**
    Add all documents from a range defined by two iterators. These
    iterators should return a document object of one of accepted types
    (as given by the is_doc_type<> trait).
  */

  template <typename It>
  CollectionAdd& add(const It &begin, const It &end)
  {
    try {
      do_add(get_impl(), begin, end);
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Add all documents within given container.

    Any container type for which `std::begin()`/`std::end()` are defined
    should work.
  */

  template <class Container>
  CollectionAdd& add(const Container &c)
  {
    try {
      do_add(get_impl(), c);
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Add document(s) to a collection.

    Documents can be described by JSON strings or DbDoc objects.
  */

  template <typename... Types>
  CollectionAdd& add(const Types&... docs)
  {
    try {
      do_add(get_impl(), docs...);
      return *this;
    }
    CATCH_AND_WRAP
  }

protected:

  using Impl = internal::Collection_add_impl;

  Impl* get_impl()
  {
    return static_cast<Impl*>(internal::Collection_add_base::get_impl());
  }

};


// ----------------------------------------------------------------------


/*
  Removing documents from a collection
  ====================================
*/

class CollectionRemove;

namespace internal {

struct Collection_remove_cmd
  : public Executable<Result,CollectionRemove>
{};

struct Collection_remove_base
  : public Sort< Limit< Bind_parameters< Collection_remove_cmd > > >
{};

}  // internal namespace


/**
  Class representing operation which removes documents from a collection.

  @ingroup devapi_op

  @internal
  Note: All methods that modify remove operation are defined by the base
  class.
*/

class PUBLIC_API CollectionRemove
  : public internal::Collection_remove_base
{

public:

  /**
    Create empty remove operation for a given collection.
  */

  CollectionRemove(Collection &coll);

  /**
    Create remove operation for given collection and documents
    selected by an expression.
  */

  CollectionRemove(Collection &coll, const string&);


  CollectionRemove(const internal::Collection_remove_cmd &other)
  {
    internal::Collection_remove_cmd::operator=(other);
  }

  CollectionRemove(internal::Collection_remove_cmd &&other)
  {
    internal::Collection_remove_cmd::operator=(std::move(other));
  }

};


// ----------------------------------------------------------------------

/*
  Searching for documents in a collection
  =======================================
*/

class CollectionFind;

namespace internal {

struct Collection_find_cmd
 : public Executable<DocResult, CollectionFind>
{};

struct Collection_find_base
 : public Group_by< Having< Sort< Limit< Offset< Bind_parameters<
            Collection_find_cmd
          > > > > > >
{};

}  // internal namespace


/**
  Operation which returns all or selected documents from a collection.

  @ingroup devapi_op
*/

DLL_WARNINGS_PUSH

class PUBLIC_API CollectionFind
  : public internal::Collection_find_base
  , internal::Collection_find_detail
{

DLL_WARNINGS_POP

  using Operation = internal::Collection_find_base;

public:

  /**
    Create operation which returns all documents from a collection.
  */

  CollectionFind(Collection &coll);

  /**
    Create operation which returns all documents from a collection
    which satisfy given criteria.
  */

  CollectionFind(Collection &coll, const string&);


  CollectionFind(const internal::Collection_find_cmd &other)
  {
    internal::Collection_find_cmd::operator=(other);
  }

  CollectionFind(internal::Collection_find_cmd &&other)
  {
    internal::Collection_find_cmd::operator=(std::move(other));
  }


public:

  /**
    Specify projection for the documents found by this query.

    Projection is either a single document expression given by `expr(<string>)`
    or a list (or collection) of strings of the form
    `"<expression> AS <path>"`. In the latter case each `<expression>`
    is evaluated and `<path>` specifies where to put the value of
    the expression in the resulting document.
  */

  template <typename... Expr>
  Operation& fields(Expr... proj)
  {
    try {
      do_fields(get_impl(), proj...);
      return *this;
    }
    CATCH_AND_WRAP
  }

protected:

  using Impl = internal::Proj_impl;

  Impl* get_impl()
  {
    return static_cast<Impl*>(internal::Collection_find_base::get_impl());
  }

};


// ----------------------------------------------------------------------

/*
  Modifying documents in a collection
  ===================================
*/

class CollectionModify;

namespace internal {

class CollectionReplace;

struct Collection_modify_cmd
  : public Executable<Result, CollectionModify>
{};

struct Collection_modify_base
  : public Sort< Limit< Bind_parameters< Collection_modify_cmd > > >
{};

struct Collection_replace_cmd
  : public Executable<Result, CollectionReplace>
{};

struct Collection_replace_base
    : public Bind_parameters< Collection_replace_cmd >
{};

/*
  Operation which replaces a document, using the id by a new one
*/

class PUBLIC_API CollectionReplace
  : public internal::Collection_replace_base
{

public:

  /*
    Create operation which replaces document with specified _id in a collection.
  */
  CollectionReplace(Collection &base,
                    const string &id,
                    internal::ExprValue &&val);

  CollectionReplace(const internal::Collection_replace_cmd &other)
  {
    internal::Collection_replace_cmd::operator=(other);
  }

  CollectionReplace(internal::Collection_replace_cmd &&other)
  {
    internal::Collection_replace_cmd::operator=(std::move(other));
  }

protected:

  using Impl = Collection_modify_impl;

  Impl* get_impl()
  {
    return static_cast<Impl*>(internal::Collection_replace_base::get_impl());
  }
};

}  // internal namespace


/**
  Operation which modifies all or selected documents in a collection.

  @ingroup devapi_op
*/

class PUBLIC_API CollectionModify
  : public internal::Collection_modify_base
{

public:

  /// Create operation which modifies selected documents in a collection.

  CollectionModify(Collection &base, const string &expr);


  CollectionModify(const internal::Collection_modify_cmd &other)
  {
    internal::Collection_modify_cmd::operator=(other);
  }

  CollectionModify(internal::Collection_modify_cmd &&other)
  {
    internal::Collection_modify_cmd::operator=(std::move(other));
  }


  /**
    Set a given field in a document to the given value.

    Field is given by a document path. The value can be either a direct literal
    or an expression given by `expr(<string>)`, evaluated on the server.
  */

  CollectionModify& set(const Field &field, internal::ExprValue &&val)
  {
    try {
      get_impl()->add_operation(Impl::SET, field, std::move(val));
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Unset a given field in a document.

    The field is given by a document path.
  */

  CollectionModify& unset(const Field &field)
  {
    try {
      get_impl()->add_operation(Impl::UNSET, field);
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Insert value into an array field of a document.

    The `field` parameter should be a document path pointing at a location
    inside an array field. The given value is inserted at this position.
  */

  CollectionModify& arrayInsert(const Field &field, internal::ExprValue &&val)
  {
    try {
      get_impl()->add_operation(Impl::ARRAY_INSERT, field, std::move(val));
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Append value to an array field of a document.

    The `field` parameter should be a document path pointing at an array
    field inside the document. The given value is appended at the end of the
    array.
  */

  CollectionModify& arrayAppend(const Field &field, internal::ExprValue &&val)
  {
    try {
      get_impl()->add_operation(Impl::ARRAY_APPEND, field, std::move(val));
      return *this;
    }
    CATCH_AND_WRAP
  }

  /**
    Delete element from an array field of a document.

    The `field` parameter should be a document path pointing at a location
    inside an array field. The element at indicated location is removed from
    the array.
  */

  CollectionModify& arrayDelete(const Field &field)
  {
    try {
      get_impl()->add_operation(Impl::ARRAY_DELETE, field);
      return *this;
    }
    CATCH_AND_WRAP
  }

protected:

  using Impl = internal::Collection_modify_impl;

  Impl* get_impl()
  {
    return static_cast<Impl*>(internal::Collection_modify_base::get_impl());
  }

};




}  // mysqlx namespace

#endif
