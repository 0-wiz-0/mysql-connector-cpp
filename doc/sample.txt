Sample code which uses Connector/C++ 2.0  {#sample}
========================================

@todo Cross-reference links for classes and methods.

The following Connector/C++ application connects to MySQL Hybrid plugin
loaded into MySQL 5.7 Server, creates a document collection, adds a few
documents to it, queries the collection and displays the result.
See @ref usage for instructions on how to build the sample code.

@dontinclude test.cc

Code which uses Connector/C++ should include the `mysqlx.h` header. The
API is declared within the `mysqlx` namespace:

@skip #include <mysqlx.h>
@until using namespace

To create a session object, specify DNS name of the host running
MySQL Server with MySQL Hybrid plugin, the port on which the plugin
listens (default port is 33060) and the user credentials:

@skipline main
@until Session accepted

Once created, the session is ready to be used. If the session can not
be established, the `XSession` constructor throws an error.

To manipulate documents in a collection, create a `Collection` object,
first asking session for that collection's `Schema` object:

@skipline Schema
@until Collection

The `true` parameter to `createCollection()` method specifies that
collection should be re-used if it already exists. Without this parameter
an attempt to create an already existing collection produces an error.

Before adding documents to the collection, all the existing documents are
removed first:

@skipline remove()

The `remove()` method can also accept an expression argument which selects
documents to be removed. Note that the `remove()` method returns
an operation that must be explicitly executed to take effect.
When executed, operation returns a result (ignored here; the results are
used later).

To insert documents use the `Collection::add()` method.
Documents are described by JSON strings using the same syntax
supported by MySQL Server. Note that double quotes are required
around field names and they must be escaped inside C strings:

@skipline {
@until cout
@until cout
@until cout
@until cout
@until }

Result of the `add()` operation is stored in the `add` variable to
be able to read identifiers of the documents that were added.
These identifiers are generated by the connector, unless added document
contains `"_id"` field which specifies its identifier.
Note how internal code block is used to delete the result when it is no
longer needed.

@note It is possible to chain several `add()` calls as follows:
`coll.add(doc1).add(doc2)...add(docN).execute()`. It is also possible
to pass several documents to a single `add()` call:
`coll.add(doc1, ..., docN).execute()`.

@todo Adding documents described by `DbDoc` objects.

To query documents of a collection use the `Collection::find()`
method:

@skipline find()

The result of the `find()` operation is stored in a variable of type
`DocResult` because it contains the returned sequence of documents that
satisfy the selection criteria. These documents can be fetched one by one
using the `RowResult::fetchOne()` method, until it returns a null row
that signals end of sequence:

@skipline fetchOne()
@until cout

Given a `DbDoc` object it is possible to iterate over its fields
as follows:

@skipline for
@until }

Note how the `DbDoc::operator[]` is used to access values of document
fields:

@skipline name
@until cout

The value of a field is automatically converted to a corresponding
C++ type. If the C++ type does not match the type of the field value,
conversion error is thrown. Currently only strings, numbers and documents are
converted to C++ types. Document values are convertible to the `DbDoc` type.

The `DbDoc::hasField()` and `DbDoc::fieldType()` methods can be used
to examine fields of a document. The following code demonstrats how
to process a `"date"` field of a document which is a subdocument:

@skipline if
@until }
@until }

Any errors thrown by Connector/C++ derive from the `mysqlx::Error` type
and can be processed as follows:

@skipline catch
@until }

See [full documentation of DevAPI] (http://insidemysql.com/mysqlx/docs/mysqlx-devapi-userguide/en/index.html)
implemented by Connector/C++. Note however, that the implementation is not yet
complete.

The complete code of the example is presented below:

@include test.cc

A sample output produced by this code:

~~~~~~~
Creating session on localhost...
Auth Valid: 
Session accepted, creating collection...
inserting document...
- added doc with id: AA71B4BF6B72E511BD76001E684A06F0
- added doc with id: 2885B4BF6B72E511BD76001E684A06F0
- added doc with id: 3492B4BF6B72E511BD76001E684A06F0
- added doc with id: myuuid-1
Fetching documents...
doc#0: {"_id": "82C29A44EB77E5116134001E684A06F0", "age": 2, "name": "bar"}
 field `_id`: 82C29A44EB77E5116134001E684A06F0
 field `age`: 2
 field `name`: bar
 name: bar

doc#1: {"_id": "AEFD9C44EB77E5116134001E684A06F0", "age": 3, "date": {"day": 20, "month": "Apr"}, "name": "baz"}
 field `_id`: AEFD9C44EB77E5116134001E684A06F0
 field `age`: 3
 field `date`: <document>
 field `name`: baz
 name: baz
- date field
  date `day`: 20
  date `month`: Apr
  month: Apr
  day: 20

Done!
~~~~~~~


<!--
  Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.

  The MySQL Connector/C++ is licensed under the terms of the GPLv2
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>, like most
  MySQL Connectors. There are special exceptions to the terms and
  conditions of the GPLv2 as it is applied to this software, see the
  FLOSS License Exception
  <http://www.mysql.com/about/legal/licensing/foss-exception.html>.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation; version 2 of the License.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
-->
